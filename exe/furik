#!/usr/bin/env ruby

$LOAD_PATH.unshift File.expand_path('../../lib', __FILE__)

require 'optparse'
require "furik"

if ARGV[0] == 'pulls'
  options = ARGV.getopts('g:l:s:e:', 'gh:true', 'ghe:true', 'start:', 'end:')

  gh = (options['g'] || options['gh']) == 'true'
  ghe = (options['l'] || options['ghe']) == 'true'
  start_date =  (options['s'] || options['start'])
  end_date = (options['e'] || options['end'])
  start_date = Date.parse(start_date) if start_date
  end_date = Date.parse(end_date) if end_date

  puts "Pull Requests#{" (#{start_date}...#{end_date})" if start_date && end_date}"
  puts '-'
  puts ''

  Furik.pull_requests(gh: gh, ghe: ghe) do |repo, issues|
    if issues && !issues.empty?
      string_issues = issues.each.with_object('') do |issue, memo|
        date = issue.created_at.localtime.to_date

        next if start_date && date < start_date
        next if end_date && date > end_date

        memo << "- [#{issue.number} #{issue.state}](#{issue.html_url}):"
        memo << " #{issue.title}"
        memo << " (#{issue.body.plain.cut})" if issue.body && !issue.body.empty?
        memo << " #{issue.created_at.localtime.to_date}\n"
      end

      unless string_issues == ''
        puts "### #{repo}"
        puts ''
        puts string_issues
        puts ''
      end
    end
  end
else
  options = ARGV.getopts(
  'g:l:d:f:t:',
  'gh:true',
  'ghe:true',
  'since:0',
  "from:#{Date.today.to_s}",
  "to:#{Date.today.to_s}"
  )

  gh = (options['g'] || options['gh']) == 'true'
  ghe = (options['l'] || options['ghe']) == 'true'
  since = (options['d'] || options['since']).to_i

  from = Date.parse(options['f'] || options['from'])
  to   = Date.parse(options['t'] || options['to'])
  diff = (to - from).to_i
  diff.zero? ? from -= since : since = diff

  period = case since
  when 999 then 'All'
  when 0 then "Today's"
  else "#{since + 1}days"
  end
  puts "#{period} Activities"
  puts '-'
  puts ''

  Furik.events_with_grouping(gh: gh, ghe: ghe, from: from, to: to) do |repo, events|
    puts "### #{repo}"
    puts ''

    events.sort_by(&:type).reverse.each_with_object({ keys: [] }) do |event, memo|

      payload_type = event.type.
      gsub('Event', '').
      gsub(/.*Comment/, 'Comment').
      gsub('Issues', 'Issue').
      underscore
      payload = event.payload.send(:"#{payload_type}")
      type = payload_type.dup

      title = case event.type
      when 'IssueCommentEvent'
        "#{payload.body.plain.cut} (#{event.payload.issue.title.cut(30)})"
      when 'CommitCommentEvent'
        payload.body.plain.cut
      when 'IssuesEvent'
        type = "#{event.payload.action}_#{type}"
        payload.title.plain.cut
      when 'PullRequestReviewCommentEvent'
        type = 'comment'
        if event.payload.pull_request.respond_to?(:title)
          "#{payload.body.plain.cut} (#{event.payload.pull_request.title.cut(30)})"
        else
          payload.body.plain.cut
        end
      else
        payload.title.plain.cut
      end

      link = payload.html_url
      key = "#{type}-#{link}"

      next if memo[:keys].include?(key)
      memo[:keys] << key

      puts "- [#{type}](#{link}): #{title}"
    end

    puts ''
  end
end
